[
  {
    "objectID": "01_develop_data_processing.html",
    "href": "01_develop_data_processing.html",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "from pyprojroot import here\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"\n\n\n\n\n\nimport polars as pl\nimport polars.selectors as cs\nfrom mizani.bounds import squish\nfrom pyprojroot import here\nfrom great_tables import GT, md, html\nfrom plotnine import *\nfrom labourcan.data_processing import read_labourcan\n\n\n\n\nread_labourcan returns a polars dataframe with columns:\n\nUnnecessary metadata columns removed\nFiltered to seasonally adjusted estimates only\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour.glimpse()\n\nRows: 12252\nColumns: 10\n$ REF_DATE    &lt;str&gt; '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01'\n$ GEO         &lt;str&gt; 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada'\n$ Industry    &lt;str&gt; 'Total employed, all industries', 'Goods-producing sector', 'Agriculture [111-112, 1100, 1151-1152]', 'Forestry, fishing, mining, quarrying, oil and gas [21, 113-114, 1153, 2100]', 'Utilities [22]', 'Construction [23]', 'Manufacturing [31-33]', 'Services-producing sector', 'Wholesale and retail trade [41, 44-45]', 'Transportation and warehousing [48-49]'\n$ Statistics  &lt;str&gt; 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate'\n$ Data type   &lt;str&gt; 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted'\n$ UOM         &lt;str&gt; 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands'\n$ VALUE       &lt;f64&gt; 9636.7, 3312.5, 463.6, 244.2, 110.4, 654.9, 1839.5, 6324.1, 1592.9, 573.2\n$ YEAR        &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH       &lt;i32&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ DATE_YMD   &lt;date&gt; 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#parameters",
    "href": "01_develop_data_processing.html#parameters",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "from pyprojroot import here\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#libraries",
    "href": "01_develop_data_processing.html#libraries",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "import polars as pl\nimport polars.selectors as cs\nfrom mizani.bounds import squish\nfrom pyprojroot import here\nfrom great_tables import GT, md, html\nfrom plotnine import *\nfrom labourcan.data_processing import read_labourcan",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#read-data",
    "href": "01_develop_data_processing.html#read-data",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "read_labourcan returns a polars dataframe with columns:\n\nUnnecessary metadata columns removed\nFiltered to seasonally adjusted estimates only\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour.glimpse()\n\nRows: 12252\nColumns: 10\n$ REF_DATE    &lt;str&gt; '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01'\n$ GEO         &lt;str&gt; 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada'\n$ Industry    &lt;str&gt; 'Total employed, all industries', 'Goods-producing sector', 'Agriculture [111-112, 1100, 1151-1152]', 'Forestry, fishing, mining, quarrying, oil and gas [21, 113-114, 1153, 2100]', 'Utilities [22]', 'Construction [23]', 'Manufacturing [31-33]', 'Services-producing sector', 'Wholesale and retail trade [41, 44-45]', 'Transportation and warehousing [48-49]'\n$ Statistics  &lt;str&gt; 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate'\n$ Data type   &lt;str&gt; 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted'\n$ UOM         &lt;str&gt; 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands'\n$ VALUE       &lt;f64&gt; 9636.7, 3312.5, 463.6, 244.2, 110.4, 654.9, 1839.5, 6324.1, 1592.9, 573.2\n$ YEAR        &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH       &lt;i32&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ DATE_YMD   &lt;date&gt; 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#change-per-month",
    "href": "01_develop_data_processing.html#change-per-month",
    "title": "Processing StatCan Data",
    "section": "% Change per month",
    "text": "% Change per month\nFirst, compute % change from previous month. This needs to be done over different subsets of data:\n\nIndustry\nGeolocation\nLabour Force Characteristic (If provided)\nGender\nAge group\n\nIn the seasonally adjusted dataset, only Industry and Geolocation are provided. The LFC is total employment, the Gender is both, and Age group is all.\n\nlabour_processed = (\n    # if we sort acesnding by time, then lag value is the month before\n    labour.sort([\"Industry\", \"YEAR\", \"MONTH\"])\n    .with_columns(\n        LAGGED_VALUE=pl.col(\"VALUE\")\n        .shift(1)\n        .over([\"Industry\"])\n    )\n    # compute percent difference\n    .with_columns((pl.col(\"VALUE\") - pl.col(\"LAGGED_VALUE\")).alias(\"DIFF\"))\n    .with_columns((pl.col(\"DIFF\") / pl.col(\"LAGGED_VALUE\")).alias(\"PDIFF\"))\n    .select(\n        pl.col(\"Industry\"),\n        cs.matches(\"Labour force characteristics\"),\n        pl.col(\"DATE_YMD\"),\n        pl.col(\"YEAR\"),\n        pl.col(\"MONTH\"),\n        cs.matches(\"VALUE\"),\n        cs.matches(\"DIFF\"),\n    )\n    .sort([\"Industry\", \"YEAR\", \"MONTH\", \"PDIFF\"])\n)\nlabour_processed.glimpse()\n\nRows: 12252\nColumns: 8\n$ Industry      &lt;str&gt; 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]'\n$ DATE_YMD     &lt;date&gt; 1976-01-01, 1976-02-01, 1976-03-01, 1976-04-01, 1976-05-01, 1976-06-01, 1976-07-01, 1976-08-01, 1976-09-01, 1976-10-01\n$ YEAR          &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH         &lt;i32&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n$ VALUE         &lt;f64&gt; 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5, 428.9\n$ LAGGED_VALUE  &lt;f64&gt; None, 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5\n$ DIFF          &lt;f64&gt; None, 3.2000000000000455, 4.599999999999966, 0.0, 8.0, 3.900000000000034, 6.0, 6.099999999999966, -0.19999999999998863, 5.399999999999977\n$ PDIFF         &lt;f64&gt; None, 0.008165348303138672, 0.011642622120981943, 0.0, 0.020015011258443835, 0.009565857247976537, 0.014577259475218658, 0.014607279693486507, -0.0004720320981826496, 0.012750885478158152",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#signed-centered-rank",
    "href": "01_develop_data_processing.html#signed-centered-rank",
    "title": "Processing StatCan Data",
    "section": "Signed Centered Rank",
    "text": "Signed Centered Rank\nNow we can compute the signed centered rank.\nDefine centered_rank_expr function which takes a polars series and returns an expression, meaning it can be used in a polars with_columns call, which is nice because it can take advantage of polars lazy-evaluation optimization.\nBelow is the definition and a test-case.\n\ndef centered_rank_expr(col):\n    \"\"\"\n    - Largest negative value gets rank -1\n    - Smallest positive value gets rank +1\n    - Zero gets rank 0\n    \"\"\"\n    return (\n        pl.when(col &lt; 0)\n        .then(\n            # minus the total # of -ve values\n            (col.rank(method=\"ordinal\", descending=True) * -1) + (col &gt; 0).sum()\n        )\n        .when(col == 0)\n        .then(pl.lit(0))\n        .when(col &gt; 0)\n        .then(col.rank(method=\"ordinal\") - (col &lt; 0).sum())\n        .otherwise(pl.lit(None))\n    )\n\n# test it on this subset of data\ntest_series = (\n    # .filter(pl.col(\"Labour force characteristics\") == \"Employment\")\n    labour_processed\n    .with_columns(pl.col(\"PDIFF\").round(decimals=4))\n    .filter(pl.col(\"YEAR\") == 2025, pl.col(\"MONTH\") == 1)\n    .select(pl.col(\"PDIFF\"))\n    .sample(n=10, seed=1)\n    .select(\"PDIFF\")\n)\n\ntest_series.with_columns(centered_rank_expr(pl.col(\"PDIFF\")).alias(\"rank\")).sort(\n    \"PDIFF\"\n)\n\n\nshape: (10, 2)\n\n\n\nPDIFF\nrank\n\n\nf64\ni64\n\n\n\n\n-0.0336\n-5\n\n\n-0.0207\n-4\n\n\n-0.0177\n-3\n\n\n-0.0101\n-2\n\n\n-0.003\n-1\n\n\n0.0006\n1\n\n\n0.0109\n2\n\n\n0.0122\n3\n\n\n0.0179\n4\n\n\n0.044\n5\n\n\n\n\n\n\nLooks good, so now we can apply to the data:\n\nlabour_processed = labour_processed.with_columns(\n    centered_rank_across_industry=centered_rank_expr(pl.col(\"PDIFF\")).over(\n        [\"YEAR\", \"MONTH\"]\n    )\n)\nlabour_processed.glimpse()\n\nRows: 12252\nColumns: 9\n$ Industry                       &lt;str&gt; 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]'\n$ DATE_YMD                      &lt;date&gt; 1976-01-01, 1976-02-01, 1976-03-01, 1976-04-01, 1976-05-01, 1976-06-01, 1976-07-01, 1976-08-01, 1976-09-01, 1976-10-01\n$ YEAR                           &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH                          &lt;i32&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n$ VALUE                          &lt;f64&gt; 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5, 428.9\n$ LAGGED_VALUE                   &lt;f64&gt; None, 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5\n$ DIFF                           &lt;f64&gt; None, 3.2000000000000455, 4.599999999999966, 0.0, 8.0, 3.900000000000034, 6.0, 6.099999999999966, -0.19999999999998863, 5.399999999999977\n$ PDIFF                          &lt;f64&gt; None, 0.008165348303138672, 0.011642622120981943, 0.0, 0.020015011258443835, 0.009565857247976537, 0.014577259475218658, 0.014607279693486507, -0.0004720320981826496, 0.012750885478158152\n$ centered_rank_across_industry  &lt;i64&gt; None, 8, 11, 0, 8, 8, 9, 8, -1, 5\n\n\n\nCheck output visually for 1 year 1 month\n\n# check 1 year 1 month\n(\n    labour_processed\n    .with_columns(pl.col(\"PDIFF\").round(decimals=4))\n    .filter(pl.col(\"YEAR\") == 2025)\n    .sort([\"YEAR\", \"MONTH\", \"PDIFF\"])\n    .select([\"YEAR\", \"MONTH\", \"Industry\", \"VALUE\", \"DIFF\", \"PDIFF\", cs.matches(\"rank\")])\n)\n\n\nshape: (168, 7)\n\n\n\nYEAR\nMONTH\nIndustry\nVALUE\nDIFF\nPDIFF\ncentered_rank_across_industry\n\n\ni32\ni32\nstr\nf64\nf64\nf64\ni64\n\n\n\n\n2025\n1\n\"Wholesale trade [41]\"\n689.4\n-24.0\n-0.0336\n-8\n\n\n2025\n1\n\"Utilities [22]\"\n155.8\n-3.3\n-0.0207\n-7\n\n\n2025\n1\n\"Other services (except public …\n771.0\n-13.9\n-0.0177\n-6\n\n\n2025\n1\n\"Forestry, fishing, mining, qua…\n337.1\n-5.6\n-0.0163\n-5\n\n\n2025\n1\n\"Business, building and other s…\n726.4\n-7.4\n-0.0101\n-4\n\n\n…\n…\n…\n…\n…\n…\n…\n\n\n2025\n8\n\"Accommodation and food service…\n1177.1\n9.2\n0.0079\n5\n\n\n2025\n8\n\"Construction [23]\"\n1636.3\n17.1\n0.0106\n6\n\n\n2025\n8\n\"Agriculture [111-112, 1100, 11…\n217.7\n4.8\n0.0225\n7\n\n\n2025\n8\n\"Utilities [22]\"\n163.5\n4.7\n0.0296\n8\n\n\n2025\n8\n\"Wholesale trade [41]\"\n731.1\n27.6\n0.0392\n9",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tracking Canada’s Labour Statistics with Plotnine",
    "section": "",
    "text": "Font name: `Playfair Display`\nFont name: `Lato`\n\n\n\n\n\n\n\n\n\nRead data\nCalculate Ranking\nSet color mapping\nCalculate stats\n\nStats"
  },
  {
    "objectID": "index.html#parameters",
    "href": "index.html#parameters",
    "title": "Tracking Canada’s Labour Statistics with Plotnine",
    "section": "",
    "text": "Font name: `Playfair Display`\nFont name: `Lato`"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Tracking Canada’s Labour Statistics with Plotnine",
    "section": "",
    "text": "Read data\nCalculate Ranking\nSet color mapping\nCalculate stats\n\nStats"
  },
  {
    "objectID": "03_things_that_didnt_work.html",
    "href": "03_things_that_didnt_work.html",
    "title": "Things that didn’t work",
    "section": "",
    "text": "This section is a non-exhaustive list problems I wasn’t able to solve with plotnine.\nNote that this tutorial was made with plotnine version 0.15.0. I fully expect that this appendix will likely very quickly become irrelevant with the many anticipated improvements that are coming to plotnine in the near future.",
    "crumbs": [
      "Things that didn't work"
    ]
  },
  {
    "objectID": "03_things_that_didnt_work.html#parameters",
    "href": "03_things_that_didnt_work.html#parameters",
    "title": "Things that didn’t work",
    "section": "Parameters",
    "text": "Parameters\n\nfrom pyprojroot import here\nimport mpl_fontkit as fk\nfrom brand_yml import Brand\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"\nFIGURE_THEME_SIZE = (9, 5)\nFILTER_YEAR = (2018, 2025)\nBRAND = Brand.from_yaml(here())\nFONT_PRIMARY = BRAND.typography.base.model_dump()[\"family\"]\nFONT_SECONDARY = \"Lato\"\nfk.install(FONT_PRIMARY)\nfk.install(FONT_SECONDARY)\nCOLOR_BACKGROUND = BRAND.color.background\n\nFont name: `Playfair Display`\nFont name: `Lato`",
    "crumbs": [
      "Things that didn't work"
    ]
  },
  {
    "objectID": "03_things_that_didnt_work.html#libraries",
    "href": "03_things_that_didnt_work.html#libraries",
    "title": "Things that didn’t work",
    "section": "Libraries",
    "text": "Libraries\n\nfrom labourcan.data_processing import (\n    read_labourcan,\n    calculate_centered_rank,\n    cut_pdiff,\n    DEFAULT_CUTS\n)\nimport polars as pl\nimport polars.selectors as cs\nfrom mizani.bounds import squish\nimport mizani.labels as ml\nimport mizani.breaks as mb\nimport textwrap\nfrom great_tables import GT, md, html\nfrom plotnine import *\nfrom IPython.display import display, Markdown\nimport matplotlib.pyplot as plt\nimport re\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\n\n# Remove Aggregated Rows\nlabour_filtered = labour.filter(\n    ~pl.col(\"Industry\").is_in(\n        [\n            \"Total employed, all industries\",\n            \"Goods-producing sector\",\n            \"Services-producing sector\",\n        ]\n    )\n)\n\n# Calculate ranking based on monthly % change\nlabour_processed = calculate_centered_rank(labour_filtered)\n\n# Bin % difference\nlabour_processed_cutted = cut_pdiff(labour_processed, DEFAULT_CUTS)\nlabour_processed_filtered = labour_processed_cutted.filter(\n    pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n)\n\nCOLOR_MAPPING = {\n    \"(-inf, -0.05]\": \"#d82828ff\",\n    \"(-0.05, -0.025]\": \"#fa6f1fff\",\n    \"(-0.025, -0.012]\": \"#f1874aff\",\n    \"(-0.012, -0.008]\": \"#f1b274ff\",\n    \"(-0.008, -0.004]\": \"#FEE08B\",\n    \"(-0.004, 0]\": \"#FFFFBF\",\n    \"0\": \"#a8a8a8ff\",\n    \"(0, 0.004]\": \"#E6F5D0\",\n    \"(0.004, 0.008]\": \"#bce091ff\",\n    \"(0.008, 0.012]\": \"#9ad65fff\",\n    \"(0.012, 0.025]\": \"#78b552ff\",\n    \"(0.025, 0.05]\": \"#5cb027ff\",\n    \"(0.05, inf]\": \"#1f6fc6ff\",\n}\nLEGEND_LABELS = [\n    \"-5%\",\n    \"\",\n    \"\",\n    \"-1%\",\n    \"\",\n    \"\",\n    \"No change\",\n    \"\",\n    \"\",\n    \"1%\",\n    \"\",\n    \"\",\n    \"5%\",\n]\n\nStats\n\ndef make_subtitle_for_industry(df, INDUSTRY):\n    # Define offsets\n    offsets = {\n        \"1M\": 1,\n        \"5M\": 5,\n        \"1Y\": 12,\n        \"5Y\": 60,\n    }\n\n    # Sort by industry + date\n    labour_offset = df\n    labour_offset = labour_offset.sort([\"Industry\", \"DATE_YMD\"])\n\n    # Compute diffs and %diffs for each horizon\n    for label, months in offsets.items():\n        labour_offset = labour_offset.with_columns(\n            [\n                (pl.col(\"DATE_YMD\").shift(months).alias(f\"DATE_YMD_{label}\")),\n                (\n                    pl.col(\"VALUE\")\n                    .shift(months)\n                    .over(\"Industry\")\n                    .alias(f\"VALUE_{label}\")\n                ),\n                (\n                    pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\")\n                ).alias(f\"DIFF_{label}\"),\n                (\n                    (pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\"))\n                    / pl.col(\"VALUE\").shift(months).over(\"Industry\")\n                    * 100\n                ).alias(f\"PDIFF_{label}\"),\n            ]\n        )\n    # convert to dictionary for easier access\n    stats = labour_offset.filter(\n        pl.col(\"Industry\") == INDUSTRY, pl.col(\"DATE_YMD\") == pl.col(\"DATE_YMD\").max()\n    ).to_dicts()[0]\n\n    periods = [\n        f\"{stats['DIFF_1M'] * 1000:&lt;+8,.0f} {f'({stats[\"PDIFF_1M\"]:+.2f}%)':&lt;10} Past Month\",\n        f\"{stats['DIFF_5M'] * 1000:&lt;+8,.0f} {f'({stats[\"PDIFF_5M\"]:+.2f}%)':&lt;10} Past 5 Months\",\n        f\"{stats['DIFF_1Y'] * 1000:&lt;+8,.0f} {f'({stats[\"PDIFF_1Y\"]:+.2f}%)':&lt;10} Past Year\",\n        f\"{stats['DIFF_5Y'] * 1000:&lt;+8,.0f} {f'({stats[\"PDIFF_5Y\"]:+.2f}%)':&lt;10} Past 5 Years\",\n    ]\n\n    subtitle_text = \"\\n\".join(periods)\n    return subtitle_text",
    "crumbs": [
      "Things that didn't work"
    ]
  },
  {
    "objectID": "02_develop_visualization.html",
    "href": "02_develop_visualization.html",
    "title": "Developing the employment heatmap visualization",
    "section": "",
    "text": "Current Canadian sentiment reflects significant economic uncertainty, with rising cost-of-living pressures, global political instability, and widespread layoffs affecting multiple sectors. For the 2025 plotnine contest, I wanted to explore official Canadian labour statistics using plotnine, a visualization library that brings the powerful Grammar of Graphics framework to Python.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#parameters",
    "href": "02_develop_visualization.html#parameters",
    "title": "Developing the employment heatmap visualization",
    "section": "2.1 Parameters",
    "text": "2.1 Parameters\nIn this initial code chunk we initialize some parameters that, later if needed, we can rerun this entire notebook with different parameters (e.g. different years).\n\n1from pyprojroot import here\n\n\n1\n\npyprojroot is similar to R’s package here, which lets us construct filepaths relative to the project root. This is very convenient especially for quarto projects with complex file organization.\n\n\n\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"\nFIGURE_THEME_SIZE = (8, 6)\nFILTER_YEAR = (2018, 2025)",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#dependencies",
    "href": "02_develop_visualization.html#dependencies",
    "title": "Developing the employment heatmap visualization",
    "section": "2.2 Dependencies",
    "text": "2.2 Dependencies\nNow load the rest of the packages. Throughout this tutorial, I will describe when functions from each of these packages are being used.\n\n# Data manipulation\nimport polars as pl\nimport polars.selectors as cs\nfrom datetime import date, datetime\n\n# Visualization\nfrom plotnine import *\n\n# Mizani helps customize the text and breaks on axes\nfrom mizani.bounds import squish\nimport mizani.labels as ml\nimport mizani.breaks as mb\nimport textwrap  # for wrapping long lines of text\n\n# Custom extract and transform functions for plot data\nfrom labourcan.data_processing import read_labourcan, calculate_centered_rank",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#load-and-preprocess-the-data",
    "href": "02_develop_visualization.html#load-and-preprocess-the-data",
    "title": "Developing the employment heatmap visualization",
    "section": "2.3 Load and preprocess the data",
    "text": "2.3 Load and preprocess the data\n\n\n\n\n\n\nNote\n\n\n\nThe data we are using is from a table called “Employment by industry, monthly, seasonally adjusted (x 1,000)” and can be downloaded using this bash script, or directly from StatCan’s website.\n\n\nThe visualization required a fair amount of data processing which is detailed in this page. The steps are summarized here:\nread_labourcan returns a polars.Data.Frame with:\n\nUnused columns removed\nFiltered to seasonally adjusted estimates only\nFiltered to Canada level estimates\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour_processed = calculate_centered_rank(labour)",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#a-first-attempt",
    "href": "02_develop_visualization.html#a-first-attempt",
    "title": "Developing the employment heatmap visualization",
    "section": "3.1 A first attempt",
    "text": "3.1 A first attempt\nToday we’re developing a heatmap to tell the story of Canada’s evolving job market, specifically highlighting how employment numbers vary across industries over time.\nThe reason why I chose a heatmap is because I wanted to communicate the distinction between growing and shrinking industries. To achieve this, I created a centered ranking system based on monthly percentage change that treats zero as the natural dividing line.\nHow the ranking works:\n\nGrowing sectors (positive % change) receive positive ranks starting from +1\nShrinking sectors (negative % change) receive negative ranks starting from -1\nRanks increase in magnitude as they move away from zero, creating a clear visual separation between expansion and contraction\n\nThis approach allows viewers to immediately distinguish between industries that are adding jobs versus those that are shedding them. For implementation details, see the calculate_centered_rank function.\n\n(\n    ggplot(\n        (\n1            labour_processed.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n2        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", color=\"PDIFF\"),\n    )\n    + geom_point(shape=\"s\")\n3    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n4    + scale_color_gradient2(\n5        limits=(-0.01, 0.01), low=\"#ff0000ff\", high=\"#0000dbff\", midpoint=0, oob=squish\n    ) \n)\n\n\n1\n\nWe filter the data inline to enable easy interactive development of the visualization\n\n2\n\nThe aesthetic mapping connects our key variables: DATE_YMD (datetime) to the x-axis, our centered ranking (i64) to the y-axis, and colors each point by monthly percentage change PDIFF (f64)\n\n3\n\nI like to start with relatively minimal theme, such as theme_tufte as a base to build up customizations\n\n4\n\nscale_color_gradient2 is ideal here because it creates a diverging color palette naturally centered around our midpoint of zero\n\n5\n\nThe limits=c(-0.01, 0.01) and oob=squish in combination creates an impactful visual effect: the color scale is capped at -1% and +1%, and values beyond these limits will have the darkest colors\n\n\n\n\n\n\n\n\n\n\n\nThis first version suffers by excessive whitespace between points, which is visually distracting. This could be addressed by increasing the point size, but the relationship of point size to the axis ranges, and the figure size makes achieving the right balance tricky.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#geom_point-or-geom_tile",
    "href": "02_develop_visualization.html#geom_point-or-geom_tile",
    "title": "Developing the employment heatmap visualization",
    "section": "3.2 geom_point or geom_tile",
    "text": "3.2 geom_point or geom_tile\nI like to start creating plots with the major components such as deciding on which geom is most appropriate.\ngeom_point is a natural starting point for any plot where both x and y are numerical variables. But geom_tile will plot rectangles specified by a center point, allowing more explicit control of the whitespace between tiles.\n\n(\n    ggplot(\n        (\n            labour_processed.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF\"),\n    )\n1    + geom_tile(height=0.95, width=30 * 0.95)\n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n    + scale_fill_gradient2(\n        limits=(-0.01, 0.01), low=\"#ff0000ff\", high=\"#0000dbff\", midpoint=0, oob=squish\n    )\n)\n\n\n1\n\nheight = 0.95 leaves a small amount of whitespace between tiles vertically. To remove horizontal whitespace, we need to specify a width. Because we are using a datetime axis, we need to specify it in unit of days. But each tile here is a month, so we need to express in units of 30, hence: width = 30*0.95.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#explicit-color-mapping-with-scale_color_manual",
    "href": "02_develop_visualization.html#explicit-color-mapping-with-scale_color_manual",
    "title": "Developing the employment heatmap visualization",
    "section": "3.3 Explicit color mapping with scale_color_manual",
    "text": "3.3 Explicit color mapping with scale_color_manual\nscale_fill_gradient2 used with squish creates a nice palette that’s centered around 0. However scale_fill_gradient2 is limited to 3 colors (high, midpoint, low), but I would like to highlight variability in the data with a lot more control than what these 3 points can provide.\nTo be more explicit with the colors, I will bin the % change variable and then map each bin to a color manually using scale_fill_manual.\n\n3.3.1 Bin with polars.Series.cut\nBinning is the process of breaking up a continuous variable into categories based on specific thresholds.\n\nlabour_processed_cutted = (\n    labour_processed.with_columns(\n        pl.col(\"PDIFF\")\n        .cut(\n            [\n                -0.05,\n                -0.025,\n                -0.012,\n                -0.0080,\n                -0.0040,\n                0,\n                0.0040,\n                0.0080,\n                0.012,\n                0.025,\n                0.05,\n            ]\n        )\n        .alias(\"PDIFF_BINNED\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"PDIFF\") == 0)\n        .then(pl.lit(\"0\"))\n        .otherwise(pl.col(\"PDIFF_BINNED\"))\n        .alias(\"PDIFF_BINNED\")\n    )\n    .sort(\"PDIFF\")\n    .with_columns(pl.col(\"PDIFF_BINNED\"))\n)\nlabour_processed_cutted.group_by(\"PDIFF_BINNED\").len()\n\n\nshape: (14, 2)\n\n\n\nPDIFF_BINNED\nlen\n\n\ncat\nu32\n\n\n\n\n\"(0.012, 0.025]\"\n1292\n\n\n\"(0.008, 0.012]\"\n1021\n\n\n\"(-0.025, -0.012]\"\n892\n\n\n\"(-0.05, -0.025]\"\n255\n\n\n\"(-0.012, -0.008]\"\n717\n\n\n…\n…\n\n\n\"(-0.004, 0]\"\n1999\n\n\n\"(0.025, 0.05]\"\n315\n\n\n\"(-inf, -0.05]\"\n47\n\n\n\"(0.004, 0.008]\"\n1736\n\n\n\"0\"\n74\n\n\n\n\n\n\nAfter binning the data by % change, we can see what happens when we map color to this new binned version:\n\n(\n    ggplot(\n        (\n            labour_processed_cutted.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(\n            x=\"DATE_YMD\",\n            y=\"centered_rank_across_industry\",\n1            fill=\"PDIFF_BINNED\",\n        ),\n    )\n    + geom_tile(height=0.95) \n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n)\n\n\n1\n\nHere, plotnine sees that we mapped a categorical variable to fill, so it uses a default palette that isn’t necessarily optimized for the continuous (ie. ordinal) nature of bins. Making matters worst, we can see that the categories are not even by default ordered correctly from negative to most positive.\n\n\n\n\n\n\n\n\n\n\n\nIt’s definitely uglier, not nicer. But that’s ok, it gives us finer control, and we’re going to use that to fix this issue in the next section…\n\n\n3.3.2 scale_fill_manual for explicit color mapping\nNow we need to order the levels, and map to a specific color palette.\nWe will make PDIFF=0% (no change) to be gray, positive values to have green and blue colors (growth = good), and negative values to be red and orange (contraction = bad) colors.\n\norder = (\n    labour_processed_cutted.drop_nulls()\n    .sort(\"PDIFF\")\n    .select(pl.col(\"PDIFF_BINNED\"))\n    .unique(maintain_order=True)\n    .to_series()\n    .to_list()\n)\n\nlabour_processed_cutted_ordered = labour_processed_cutted.with_columns(\n    pl.col(\"PDIFF_BINNED\").cast(pl.Enum(order))\n)\n\n1color_mapping = {\n    \"(-inf, -0.05]\": \"#d82828ff\",\n    \"(-0.05, -0.025]\": \"#fa6f1fff\",\n    \"(-0.025, -0.012]\": \"#f1874aff\",\n    \"(-0.012, -0.008]\": \"#f1b274ff\",\n    \"(-0.008, -0.004]\": \"#FEE08B\",\n    \"(-0.004, 0]\": \"#FFFFBF\",\n    \"0\": \"#a8a8a8ff\",\n    \"(0, 0.004]\": \"#E6F5D0\",\n    \"(0.004, 0.008]\": \"#bce091ff\",\n    \"(0.008, 0.012]\": \"#9ad65fff\",\n    \"(0.012, 0.025]\": \"#78b552ff\",\n    \"(0.025, 0.05]\": \"#5cb027ff\",\n    \"(0.05, inf]\": \"#1f6fc6ff\",\n}\n\n(\n    ggplot(\n        (\n            labour_processed_cutted.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"), \n    )\n    + geom_tile(color=\"white\")\n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n2    + scale_fill_manual(values=color_mapping, breaks=order)\n)\n\n\n1\n\nFirst, we define a dictionary that specifies an explicit mapping of bins to color\n\n2\n\nThen, we provide the dictionary to values in scale_fill_manual\n\n\n\n\n\n\n\n\n\n\n\nNow we have a much nicer looking color palette for our graphic. This process illustrates a few things:\n\nscale_fill_gradient2\n\nWorked well “out-of-the-box”\nBut is limited for more fine-grained control over the gradient\n\nscale_fill_manual plus our binning procedure\n\nallows us to explicitly control how color is mapped to the data.\nFor example, this approach allows us to highlight more extreme values with how we define extreme (e.g. &gt;+5%, &lt;-5%), or non significant data (0% no change)\nBut the cost was that it takes a lot more effort and lines of code",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#customizing-the-plotnine-legend",
    "href": "02_develop_visualization.html#customizing-the-plotnine-legend",
    "title": "Developing the employment heatmap visualization",
    "section": "3.4 Customizing the plotnine legend",
    "text": "3.4 Customizing the plotnine legend\n… which in its current form, is mathematically accurate, but we can make it much nicer to look at.\nLet’s start by making the text more concise:\n\nWe don’t need every bin to be labelled\nInstead of listing the range, we can just describe the midpoint\n\n\n1legend_labels = [\n    \"-5%\",  # the ends can be labelled with the boundary e.g. implies &lt;-5%\n    \"\",\n    \"\",\n    \"-1%\",\n    \"\",\n    \"\",\n    \"No change\",\n    \"\",\n    \"\",\n    \"\",\n    \"1%\",\n    \"\",\n    \"5%\",\n]\n\n(\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\")\n    + theme_tufte()\n    + theme(\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_x=element_text(angle=90),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title=element_blank(),\n        legend_key_spacing=0,\n        legend_key_width=10,\n        legend_key_height=10,\n        legend_text=element_text(size=8),\n    )\n2    + scale_fill_manual(\n        values=color_mapping, breaks=order, labels=legend_labels\n    )\n)\n\n\n1\n\nSimilar to values, for labels we define a list that is the same length as the breaks\n\n2\n\nAnd then we provide the list legend_labels to scale_fill_manual\n\n\n\n\n\n\n\n\n\n\n\nThe legend looks a lot nicer, and easier to immediately grasp the range of the data. Even though I originally wanted to make a horizontal legend, this vertical version is a lot easier to implement and looks equally good. ## Text and fonts\nNext up is the text and fonts. I played with a few fonts on google fonts before settling on two.\nInstall the fonts:\n\nFONT_PRIMARY = \"Playfair Display\"\nFONT_SECONDARY = \"Lato\"\nimport mpl_fontkit as fk\nfk.install(FONT_PRIMARY)\nfk.install(FONT_SECONDARY)\n\nFont name: `Playfair Display`\nFont name: `Lato`\n\n\n\n3.4.1 Consistent theming with Brand.yml\nAlternatively, if we utilize brand.yml, we can pull these settings directly from it.\n\nfrom brand_yml import Brand\n\nBRAND = Brand.from_yaml(here())\nFONT_PRIMARY = BRAND.typography.base.model_dump()[\"family\"]\nCOLOR_BACKGROUND = BRAND.color.background\n\n\n\n\n\n\n\nNote\n\n\n\nWe can also connect other components like using the the brand’s color as our plot background, which will make it the same as the surrounding background from our quarto website.\nSee this project’s brand.yml here\n\n\n\nImport the brand data and extract the family from typography\nImport other components, e.g. color\n\nThis is convenient because if we want to change the font we can just edit the brand.yml configuration, and these changes will automatically propagate throughout any connected document like this one.\n\n\n3.4.2 mizani for axis breaks and labels\nThe axis breaks and labels for Plotnine graphs can be easily customized using mizani, which is ggplot2’s scales package for python.\nWe’re going to use mizani.breaks.breaks_date_width so that the x-axis shows each year, and mizani.labels.label_date to drop the “month” part of the date.\n\nimport mizani.labels as ml\nimport mizani.breaks as mb\n\nplot = (\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\", height=0.95)\n    + theme_tufte()\n    + theme(\n1        text=element_text(family=FONT_PRIMARY),\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_y=element_text(family=FONT_SECONDARY),\n        axis_text_x=element_text(family=FONT_SECONDARY),\n        axis_title_y=element_text(weight=300),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title_position=\"top\",\n        legend_key_spacing=0,\n        legend_key_width=15,\n        legend_key_height=15,\n        legend_text=element_text(size=8, family=FONT_SECONDARY),\n        legend_title=element_blank(),\n        plot_title=element_text(ha=\"left\"),\n        plot_subtitle=element_text(ha=\"left\", margin={\"b\": 1, \"units\": \"lines\"}),\n        plot_background=element_rect(fill=COLOR_BACKGROUND, color=COLOR_BACKGROUND),\n    )\n    + scale_fill_manual(values=color_mapping, breaks=order, labels=legend_labels)\n    + guides(fill=guide_legend(ncol=1, reverse=True))\n    + scale_x_datetime(\n2        labels=ml.label_date(\"%Y\"),\n        expand=(0, 0),\n        breaks=mb.breaks_date_width(\"1 years\"),\n    )\n3    + labs(\n        title=\"Sector Shifts: Where Canada's Jobs Are Moving\",\n        subtitle=textwrap.fill(\n            \"Track the number of industries gaining or losing jobs each month. Boxes are shaded based on percentage change from previous month in each industry's employment levels.\",\n            width=75,\n        ),\n        x=\"\",\n        y=\"&lt; SECTORS FALLING            SECTORS RISING &gt;\",\n    )\n)\nplot\n\n\n1\n\nApply font family changes to the primary font in theme(...)\n\n2\n\nUse mizani to customize axis breaks and labels to show year\n\n3\n\nAdd title, subtitle and wrap long lines with the help of textwrap",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#conclusion-of-the-base-graphic",
    "href": "02_develop_visualization.html#conclusion-of-the-base-graphic",
    "title": "Developing the employment heatmap visualization",
    "section": "3.5 Conclusion of the base graphic",
    "text": "3.5 Conclusion of the base graphic\nAnd that concludes generating the employment heatmap.\nAt the beginning, I wanted to stop here. However, I found the visualization sparks more questions.\nAlthough the graphic clearly shows contractions and growth over time, it lacks details that I think are critical for meaningful interpretation:\nWhat are the specific industries that are growing and shrinking? And by how much?",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#highlighting-an-industry",
    "href": "02_develop_visualization.html#highlighting-an-industry",
    "title": "Developing the employment heatmap visualization",
    "section": "4.1 Highlighting an Industry",
    "text": "4.1 Highlighting an Industry\n\n1INDUSTRY = \"Wholesale and retail trade [41, 44-45]\"\n\n2plot_data_subsetted = labour_processed_cutted.filter(\n    pl.col(\"YEAR\") &gt;= FILTER_YEAR[0],\n    pl.col(\"YEAR\") &lt;= FILTER_YEAR[1],\n    pl.col(\"Industry\") == INDUSTRY,\n)\n\nplot_highlight_industry = (\n    plot\n3    + geom_point(data=plot_data_subsetted, color=\"black\", fill=\"black\")\n    + labs(title=INDUSTRY, subtitle=\"\")\n)\nplot_highlight_industry\n\n\n1\n\nSpecify the target industry to highlight\n\n2\n\nFilter data to the selected industry and time range\n\n3\n\nLayer the filtered data as black points over the existing heatmap with geom_point\n\n\n\n\n\n\n\n\n\n\n\nThis approach allows us to trace specific industry trends in the context of the broader employment dynamics.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#adding-statistics-to-the-plot",
    "href": "02_develop_visualization.html#adding-statistics-to-the-plot",
    "title": "Developing the employment heatmap visualization",
    "section": "4.2 Adding statistics to the plot",
    "text": "4.2 Adding statistics to the plot\nI think adding a few key statistics to the graphic will leave a more impactful impression on readers.\nIn this section I compute the change, and % change for the last:\n\n1 month\n5 months\n1 year\n5 years\n\n\n# Define offsets\noffsets = {\n    \"1M\": 1,\n    \"5M\": 5,\n    \"1Y\": 12,\n    \"5Y\": 60,\n}\n\n# Sort by industry + date\nlabour_offset = labour_processed_cutted\nlabour_offset = labour_offset.sort([\"Industry\", \"DATE_YMD\"])\n\n# Compute diffs and %diffs for each horizon\nfor label, months in offsets.items():\n    labour_offset = labour_offset.with_columns(\n        [\n            (pl.col(\"DATE_YMD\").shift(months).alias(f\"DATE_YMD_{label}\")),\n            (pl.col(\"VALUE\").shift(months).over(\"Industry\").alias(f\"VALUE_{label}\")),\n            (pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\")).alias(\n                f\"DIFF_{label}\"\n            ),\n            (\n                (pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\"))\n                / pl.col(\"VALUE\").shift(months).over(\"Industry\")\n                * 100\n            ).alias(f\"PDIFF_{label}\"),\n        ]\n    )\n\n# convert to dictionary for easier access\nstats = labour_offset.filter(\n    pl.col(\"Industry\") == INDUSTRY, pl.col(\"DATE_YMD\") == pl.col(\"DATE_YMD\").max()\n).to_dicts()[0]\n\n# generate a string that we can use as a subtitle\nperiods = [\n    f\"{stats['DIFF_1M']:&lt;+4.0f} {f'({stats[\"PDIFF_1M\"]:+.2f}%)':&lt;10} 1 Month\",\n    f\"{stats['DIFF_5M']:&lt;+4.0f} {f'({stats[\"PDIFF_5M\"]:+.2f}%)':&lt;10} 5 Months\",\n    f\"{stats['DIFF_1Y']:&lt;+4.0f} {f'({stats[\"PDIFF_1Y\"]:+.2f}%)':&lt;10} 1 Year\",\n    f\"{stats['DIFF_5Y']:&lt;+4.0f} {f'({stats[\"PDIFF_5Y\"]:+.2f}%)':&lt;10} 5 Years\",\n]\nsubtitle_text = \"\\n\".join(periods)\n\nThe plan is to add these into the plot as a subtitle. I would love to additionally set green and red colors to positive and negative values, but that isn’t currently possible in plotnine. However, #612 suggests this may be possible in the longer term.\n\nimport re\n\n(\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\", height=0.95)\n    + theme_tufte()\n    + theme(\n        text=element_text(family=FONT_PRIMARY),\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_y=element_text(family=FONT_SECONDARY),\n        axis_text_x=element_text(family=FONT_SECONDARY),\n        axis_title_y=element_text(weight=300),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title_position=\"top\",\n        legend_key_spacing=0,\n        legend_key_width=15,\n        legend_key_height=15,\n        legend_text=element_text(size=8, family=FONT_SECONDARY),\n        legend_title=element_blank(),\n        plot_title=element_text(ha=\"left\"),\n        plot_subtitle=element_text(ha=\"left\", margin={\"b\": 1, \"units\": \"lines\"}),\n        plot_background=element_rect(fill=COLOR_BACKGROUND, color=COLOR_BACKGROUND),\n    )\n    + scale_fill_manual(values=color_mapping, breaks=order, labels=legend_labels)\n    + guides(fill=guide_legend(ncol=1, reverse=True))\n    + scale_x_datetime(\n        labels=ml.label_date(\"%Y\"),\n        expand=(0, 0),\n        breaks=mb.breaks_date_width(\"1 years\"),\n    )\n    + labs(\n1        title=re.sub(r\" \\[.*?\\]$\", \"\", INDUSTRY),\n2        subtitle=subtitle_text,\n        x=\"\",\n        y=\"&lt; SECTORS FALLING            SECTORS RISING &gt;\",\n    )\n    + geom_point(data=plot_data_subsetted, color=\"black\", fill=\"black\")\n)\n\n\n1\n\nUse inline regex to remove the trailing special characters\n\n2\n\nadd subtitle_text to labs",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  }
]