[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Track Canada’s Labour Statistics",
    "section": "",
    "text": "Font name: `Playfair Display`\nFont name: `Lato`\n\n\n\n\n\n\n\n\n\nRead data\nCalculate Ranking\nSet color mapping\nCalculate stats\n\nStats"
  },
  {
    "objectID": "index.html#parameters",
    "href": "index.html#parameters",
    "title": "Track Canada’s Labour Statistics",
    "section": "",
    "text": "Font name: `Playfair Display`\nFont name: `Lato`"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Track Canada’s Labour Statistics",
    "section": "",
    "text": "Read data\nCalculate Ranking\nSet color mapping\nCalculate stats\n\nStats"
  },
  {
    "objectID": "02_develop_visualization.html",
    "href": "02_develop_visualization.html",
    "title": "Developing the employment heatmap visualization",
    "section": "",
    "text": "Current Canadian sentiment is at a low, with high cost-of-living, global political instability, and sweeping layoffs across multiple sectors. For the 2025 plotnine contest, I wanted to explore current official Canadian labour statistics using plotnine, a data visualization library in python.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#data",
    "href": "02_develop_visualization.html#data",
    "title": "Developing the employment heatmap visualization",
    "section": "2.1 Data",
    "text": "2.1 Data\nThe data can be downloaded using this bash script, or directly from StatCan’s website.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#parameters",
    "href": "02_develop_visualization.html#parameters",
    "title": "Developing the employment heatmap visualization",
    "section": "2.2 Parameters",
    "text": "2.2 Parameters\nIn this initial code chunk we initialize some parameters that, later if needed, we can rerun this entire notebook with different parameters (e.g. different years). Read more about Quarto parameters here.\n\n1from pyprojroot import here\n\n\n1\n\npyprojroot is similar to R’s package here, which lets us construct filepaths relative to the project root. This is very convenient especially for quarto projects with complex file organization.\n\n\n\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"\nFIGURE_THEME_SIZE = (8, 6)\nFILTER_YEAR = (2018, 2025)",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#dependencies",
    "href": "02_develop_visualization.html#dependencies",
    "title": "Developing the employment heatmap visualization",
    "section": "2.3 Dependencies",
    "text": "2.3 Dependencies\nNow load the rest of the packages. Throughout this tutorial, I will describe when functions from each of these packages are being used.\n\n# Data manipulation\nimport polars as pl\nimport polars.selectors as cs\nfrom datetime import date, datetime\n\n# Visualization\nfrom plotnine import *\n\n# Mizani helps customize the text and breaks on axes\nfrom mizani.bounds import squish\nimport mizani.labels as ml\nimport mizani.breaks as mb\nimport textwrap  # for wrapping long lines of text\n\n# Custom extract and transform functions for plot data\nfrom labourcan.data_processing import read_labourcan, calculate_centered_rank",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#read-and-process-data-for-graphing",
    "href": "02_develop_visualization.html#read-and-process-data-for-graphing",
    "title": "Developing the employment heatmap visualization",
    "section": "2.4 Read and process data for graphing",
    "text": "2.4 Read and process data for graphing\nThe visualization required a fair amount of data processing which is detailed in this page. The steps are summarized here:\nread_labourcan returns a polars.Data.Frame with:\n\nUnused columns removed\nFiltered to seasonally adjusted estimates only\nFiltered to Canada level estimates\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\nSee labour.qmd for details on data processing.\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour_processed = calculate_centered_rank(labour)\n\nThe data is several gigabytes large. Because of this, the data is not stored in the github repo. Please use this script to download the data.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#a-first-attempt",
    "href": "02_develop_visualization.html#a-first-attempt",
    "title": "Developing the employment heatmap visualization",
    "section": "3.1 A first attempt",
    "text": "3.1 A first attempt\nThe type of graphic that we’re developing today can be described as something like a heatmap of employment numbers.\nThe motivation is to tell a story about Canada’s job sector, and specifically the variation in employment numbers over time. Thefore, I wanted to create a visualization that would clearly separate industries that are growing versus shrinking.\nTherefore, I derived a rank ordering by % monthly changed, but that is centered around 0, such that growing sectors with a positive % change will have a positive ranking and shrinking sectors will have a negative one. The ranking will start at 1 / -1, and increase / decrease away from 0. See calculate_centered_rank for implementation details.\n\n(\n    ggplot(\n        (\n1            labour_processed.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n2        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", color=\"PDIFF\"),\n    )\n    + geom_point(shape=\"s\")\n3    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n4    + scale_color_gradient2(\n5        limits=(-0.01, 0.01), low=\"#ff0000ff\", high=\"#0000dbff\", midpoint=0, oob=squish\n    ) \n)\n\n\n1\n\nWe filter the data inline so that we can easily interactively develop our graphic\n\n2\n\nWe use aes to map our variables: DATE_YMD (date in datetime format) to x, ranking (i64) to y, and color each point by the percent monthly change PDIFF (f64).\n\n3\n\nI like to start with relatively minimal theme, such as theme_tufte as a base to build up customizations\n\n4\n\nscale_color_gradient2 is a great color mapping function because it can allow us to easily specify that we want a palette that centers around a midpoint (0).\n\n5\n\nThe limits=c(-0.01, 0.01) and oob=squish is very impactful here, which in combination makes the color palette stop at a -1% and +1%, everything that is beyond these limits will take on the darkest colors.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#geom_point-or-geom_tile",
    "href": "02_develop_visualization.html#geom_point-or-geom_tile",
    "title": "Developing the employment heatmap visualization",
    "section": "3.2 geom_point or geom_tile",
    "text": "3.2 geom_point or geom_tile\nI like to start shaping plots by starting with the major components, which geom is most appropriate for this type of data?\nThis first version has quite a bit of whitespace between each point, which I find is distracting. I could make the point size larger, but the ratio of point size to the range of the x and y axis, as well as the figure size all will ultimately determine how much whitespace remains between each point. This makes sizing tricky.\nIf we use geom_tile instead, which will plot rectangles specified by a center point, we can explicitly control the whitespace between tiles.\n\n(\n    ggplot(\n        (\n            labour_processed.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF\"),\n    )\n1    + geom_tile(height=0.95, width=30 * 0.95)\n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n    + scale_fill_gradient2(\n        limits=(-0.01, 0.01), low=\"#ff0000ff\", high=\"#0000dbff\", midpoint=0, oob=squish\n    )\n)\n\n\n1\n\nheight = 0.95 leaves a small amount of whitespace between tiles vertically. To remove horizontal whitespace, we need to specify a width. Because we are using a datetime axis, we need to specify it in unit of days. But each tile here is a month, so we need to express in units of 30, hence: width = 30*0.95.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#explicit-color-mapping-with-scale_color_manual",
    "href": "02_develop_visualization.html#explicit-color-mapping-with-scale_color_manual",
    "title": "Developing the employment heatmap visualization",
    "section": "3.3 Explicit color mapping with scale_color_manual",
    "text": "3.3 Explicit color mapping with scale_color_manual\nscale_fill_gradient2 used with squish creates a nice palette that’s centered around 0. However scale_fill_gradient2 is limited to 3 colors (high, midpoint, low), but I would like to highlight variability in the data with a lot more control than what these 3 points can provide.\nTo be more explicit with the colors, I will bin the % change variable and then map each bin to a color manually using scale_fill_manual.\n\n3.3.1 Bin with polars.Series.cut\nBinning is the process of breaking up a continuous variable into categories based on specific thresholds.\n\nlabour_processed_cutted = (\n    labour_processed.with_columns(\n        pl.col(\"PDIFF\")\n        .cut(\n            [\n                -0.05,\n                -0.025,\n                -0.012,\n                -0.0080,\n                -0.0040,\n                0,\n                0.0040,\n                0.0080,\n                0.012,\n                0.025,\n                0.05,\n            ]\n        )\n        .alias(\"PDIFF_BINNED\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"PDIFF\") == 0)\n        .then(pl.lit(\"0\"))\n        .otherwise(pl.col(\"PDIFF_BINNED\"))\n        .alias(\"PDIFF_BINNED\")\n    )\n    .sort(\"PDIFF\")\n    .with_columns(pl.col(\"PDIFF_BINNED\"))\n)\nlabour_processed_cutted.group_by(\"PDIFF_BINNED\").len()\n\n\nshape: (14, 2)\n\n\n\nPDIFF_BINNED\nlen\n\n\ncat\nu32\n\n\n\n\n\"(0.025, 0.05]\"\n315\n\n\n\"(-0.008, -0.004]\"\n1201\n\n\n\"(0, 0.004]\"\n2624\n\n\nnull\n21\n\n\n\"(-0.025, -0.012]\"\n892\n\n\n…\n…\n\n\n\"(0.012, 0.025]\"\n1292\n\n\n\"(-inf, -0.05]\"\n47\n\n\n\"(0.05, inf]\"\n58\n\n\n\"(0.008, 0.012]\"\n1021\n\n\n\"(-0.012, -0.008]\"\n717\n\n\n\n\n\n\nAfter binning the data by % change, we can see what happens when we map color to this new binned version:\n\n(\n    ggplot(\n        (\n            labour_processed_cutted.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(\n            x=\"DATE_YMD\",\n            y=\"centered_rank_across_industry\",\n1            fill=\"PDIFF_BINNED\",\n        ),\n    )\n    + geom_tile(height=0.95) \n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n)\n\n\n1\n\nHere, plotnine sees that we mapped a categorical variable to fill, so it uses a default palette that isn’t necessarily optimized for the continuous (ie. ordinal) nature of bins. To offend even further, we can see that the categories are not even by default ordered correctly (most negative to most positive).\n\n\n\n\n\n\n\n\n\n\n\nIt’s definitely uglier, not nicer. But that’s ok, it’s giving us finer control, and we’re going to use that to fix this in the next section…\n\n\n3.3.2 scale_fill_manual for explicit color mapping\nNow we need to order the levels, and map to a specific color palette.\nWe will make PDIFF=0% (no change) to be gray, positive values to have green and blue colors (growth = good), and negative values to be red and orange (contraction = bad) colors.\n\norder = (\n    labour_processed_cutted.drop_nulls()\n    .sort(\"PDIFF\")\n    .select(pl.col(\"PDIFF_BINNED\"))\n    .unique(maintain_order=True)\n    .to_series()\n    .to_list()\n)\n\nlabour_processed_cutted_ordered = labour_processed_cutted.with_columns(\n    pl.col(\"PDIFF_BINNED\").cast(pl.Enum(order))\n)\n\n1color_mapping = {\n    \"(-inf, -0.05]\": \"#d82828ff\",\n    \"(-0.05, -0.025]\": \"#fa6f1fff\",\n    \"(-0.025, -0.012]\": \"#f1874aff\",\n    \"(-0.012, -0.008]\": \"#f1b274ff\",\n    \"(-0.008, -0.004]\": \"#FEE08B\",\n    \"(-0.004, 0]\": \"#FFFFBF\",\n    \"0\": \"#a8a8a8ff\",\n    \"(0, 0.004]\": \"#E6F5D0\",\n    \"(0.004, 0.008]\": \"#bce091ff\",\n    \"(0.008, 0.012]\": \"#9ad65fff\",\n    \"(0.012, 0.025]\": \"#78b552ff\",\n    \"(0.025, 0.05]\": \"#5cb027ff\",\n    \"(0.05, inf]\": \"#1f6fc6ff\",\n}\n\n(\n    ggplot(\n        (\n            labour_processed_cutted.filter(\n                pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n            )\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"), \n    )\n    + geom_tile(color=\"white\")\n    + theme_tufte()\n    + theme(figure_size=FIGURE_THEME_SIZE, axis_text_x=element_text(angle=90))\n2    + scale_fill_manual(values=color_mapping, breaks=order)\n)\n\n\n1\n\nFirst, we define a dictionary that specifies an explicit mapping of bins to color\n\n2\n\nThen, we provide the dictionary to values in scale_fill_manual\n\n\n\n\n\n\n\n\n\n\n\nNow we have a much nicer looking color palette for our graphic. This process illustrates a few things:\n\nscale_fill_gradient2\n\nWorked well “out-of-the-box”\nBut is limited for more fine-grained control over the gradient\n\nscale_fill_manual plus our binning procedure\n\nallows us to explicitly control how color is mapped to the data.\nFor example, this approach allows us to highlight more extreme values with how we define extreme (e.g. &gt;+5%, &lt;-5%), or non significant data (0% no change)\nBut the cost was that it takes a lot more effort and lines of code",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#customizing-the-plotnine-legend",
    "href": "02_develop_visualization.html#customizing-the-plotnine-legend",
    "title": "Developing the employment heatmap visualization",
    "section": "3.4 Customizing the plotnine legend",
    "text": "3.4 Customizing the plotnine legend\n… which in its current form, is mathematically accurate, but we can make it much nicer to look at.\nLet’s start by making the text more concise:\n\nWe don’t need every bin to be labelled\nInstead of listing the range, we can just describe the midpoint\n\n\n1legend_labels = [\n    \"-5%\",  # the ends can be labelled with the boundary e.g. implies &lt;-5%\n    \"\",\n    \"\",\n    \"-1%\",\n    \"\",\n    \"\",\n    \"No change\",\n    \"\",\n    \"\",\n    \"\",\n    \"1%\",\n    \"\",\n    \"5%\",\n]\n\n(\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\")\n    + theme_tufte()\n    + theme(\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_x=element_text(angle=90),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title=element_blank(),\n        legend_key_spacing=0,\n        legend_key_width=10,\n        legend_key_height=10,\n        legend_text=element_text(size=8),\n    )\n2    + scale_fill_manual(\n        values=color_mapping, breaks=order, labels=legend_labels\n    )\n)\n\n\n1\n\nSimilar to values, for labels we define a list that is the same length as the breaks\n\n2\n\nAnd then we provide the list legend_labels to scale_fill_manual\n\n\n\n\n\n\n\n\n\n\n\nI originally wanted to make a horizontal legend, but this works much better.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#text-and-fonts",
    "href": "02_develop_visualization.html#text-and-fonts",
    "title": "Developing the employment heatmap visualization",
    "section": "3.5 Text and fonts",
    "text": "3.5 Text and fonts\nNext up is the text and fonts. I played with a few fonts on google fonts before settling on two. Note that this website uses these fonts with the help of brand.yml\nInstall the fonts:\n\nFONT_PRIMARY = \"Playfair Display\"\nFONT_SECONDARY = \"Lato\"\nimport mpl_fontkit as fk\nfk.install(FONT_PRIMARY)\nfk.install(FONT_SECONDARY)\n\nFont name: `Playfair Display`\nFont name: `Lato`\n\n\n\n3.5.1 Consistent theming with Brand.yml\nAlternatively, if we utilize brand.yml, we can pull these settings directly from it.\n\nfrom brand_yml import Brand\n\nBRAND = Brand.from_yaml(here())\n1FONT_PRIMARY = BRAND.typography.base.model_dump()[\"family\"]\n2COLOR_BACKGROUND = BRAND.color.background\n\n\n1\n\nImport the brand data and extract the family from typography\n\n2\n\nImport other components, e.g. color\n\n\n\n\nThat’s nice because if we want to change the font we can just edit the brand.yml configuration, and these changes will automatically propagate throughout any connected document like this one.\nWe can also connect other components like using the the brand’s color as our plot background, which will make it the same as the surrounding background from our quarto website.\nRead more about Brand here.\n\n\n3.5.2 mizani for axis breaks and labels\nThe axis breaks and labels for Plotnine graphs can be easily customized using mizani, which is the “scales” package for python.\nWe’re going to use mizani.breaks.breaks_date_width to put breaks for each year, and mizani.labels.label_date to drop the “month” part of the date.\n\nimport mizani.labels as ml\nimport mizani.breaks as mb\n\nplot = (\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\", height=0.95)\n    + theme_tufte()\n    + theme(\n1        text=element_text(family=FONT_PRIMARY),\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_y=element_text(family=FONT_SECONDARY),\n        axis_text_x=element_text(family=FONT_SECONDARY),\n        axis_title_y=element_text(weight=300),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title_position=\"top\",\n        legend_key_spacing=0,\n        legend_key_width=15,\n        legend_key_height=15,\n        legend_text=element_text(size=8, family=FONT_SECONDARY),\n        legend_title=element_blank(),\n        plot_title=element_text(ha=\"left\"),\n        plot_subtitle=element_text(ha=\"left\", margin={\"b\": 1, \"units\": \"lines\"}),\n        plot_background=element_rect(fill=COLOR_BACKGROUND, color=COLOR_BACKGROUND),\n    )\n    + scale_fill_manual(values=color_mapping, breaks=order, labels=legend_labels)\n    + guides(fill=guide_legend(ncol=1, reverse=True))\n    + scale_x_datetime(\n2        labels=ml.label_date(\"%Y\"),\n        expand=(0, 0),\n        breaks=mb.breaks_date_width(\"1 years\"),\n    )\n3    + labs(\n        title=\"Sector Shifts: Where Canada's Jobs Are Moving\",\n        subtitle=textwrap.fill(\n            \"Track the number of industries gaining or losing jobs each month. Boxes are shaded based on percentage change from previous month in each industry's employment levels.\",\n            width=75,\n        ),\n        x=\"\",\n        y=\"&lt; SECTORS FALLING            SECTORS RISING &gt;\",\n    )\n)\nplot\n\n\n1\n\nApply font family changes to the primary font in theme(...)\n\n2\n\nUse mizani to format labels to show only the year in scale_x_datetime\n\n3\n\nAdd title, subtitle and wrap long lines with the help of textwrap",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#conclusion-of-the-base-graphic",
    "href": "02_develop_visualization.html#conclusion-of-the-base-graphic",
    "title": "Developing the employment heatmap visualization",
    "section": "3.6 Conclusion of the base graphic",
    "text": "3.6 Conclusion of the base graphic\nAnd that concludes generating the employment heatmap. However, I found this graphic to be lacking in depth: what are the industries that are growing and shrinking? And by how much?",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#highlighting-an-industry",
    "href": "02_develop_visualization.html#highlighting-an-industry",
    "title": "Developing the employment heatmap visualization",
    "section": "4.1 Highlighting an Industry",
    "text": "4.1 Highlighting an Industry\n\n1INDUSTRY = 'Wholesale and retail trade [41, 44-45]'\n\n2plot_data_subsetted = labour_processed_cutted.filter(\n    pl.col(\"YEAR\") &gt;= FILTER_YEAR[0],                                     \n    pl.col(\"YEAR\") &lt;= FILTER_YEAR[1],                                     \n    pl.col('Industry') == INDUSTRY                                       \n)\n\nplot_highlight_industry = (\n    plot\n3    + geom_point(data=plot_data_subsetted, color='black', fill='black')\n    + labs(title = INDUSTRY, subtitle = '')\n)\nplot_highlight_industry\n\n\n1\n\nSpecify indsutry\n\n2\n\nSubset data\n\n3\n\nAdd the subsetted data to another geom_point layer\n\n\n\n\n\n\n\n\n\n\n\nGreat, now we can indicate a specific industry’s data onto the graphic.\nBut I personally still find the graphic a bit unsatisfying as it is hard to read out any specific numbers from it.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#adding-statistics-to-the-plot",
    "href": "02_develop_visualization.html#adding-statistics-to-the-plot",
    "title": "Developing the employment heatmap visualization",
    "section": "4.2 Adding statistics to the plot",
    "text": "4.2 Adding statistics to the plot\nI think adding a few raw numbers to the graphic will leave a more impactful impression on readers.\nIn this section I compute the change, and % change for the last:\n\n1 month\n5 months\n1 year\n5 years\n\n\n# Define offsets\noffsets = {\n    \"1M\": 1,\n    \"5M\": 5,\n    \"1Y\": 12,\n    \"5Y\": 60,\n}\n\n# Sort by industry + date\nlabour_offset = labour_processed_cutted\nlabour_offset = labour_offset.sort([\"Industry\", \"DATE_YMD\"])\n\n# Compute diffs and %diffs for each horizon\nfor label, months in offsets.items():\n    labour_offset = labour_offset.with_columns(\n        [\n            (pl.col(\"DATE_YMD\").shift(months).alias(f\"DATE_YMD_{label}\")),\n            (pl.col(\"VALUE\").shift(months).over(\"Industry\").alias(f\"VALUE_{label}\")),\n            (pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\")).alias(\n                f\"DIFF_{label}\"\n            ),\n            (\n                (pl.col(\"VALUE\") - pl.col(\"VALUE\").shift(months).over(\"Industry\"))\n                / pl.col(\"VALUE\").shift(months).over(\"Industry\")\n                * 100\n            ).alias(f\"PDIFF_{label}\"),\n        ]\n    )\n\n# convert to dictionary for easier access\nstats = labour_offset.filter(\n    pl.col(\"Industry\") == INDUSTRY, pl.col(\"DATE_YMD\") == pl.col(\"DATE_YMD\").max()\n).to_dicts()[0]\n\n# generate a string that we can use as a subtitle\nperiods = [\n    f\"{stats['DIFF_1M']:&lt;+4.0f} {f'({stats[\"PDIFF_1M\"]:+.2f}%)':&lt;10} 1 Month\",\n    f\"{stats['DIFF_5M']:&lt;+4.0f} {f'({stats[\"PDIFF_5M\"]:+.2f}%)':&lt;10} 5 Months\",\n    f\"{stats['DIFF_1Y']:&lt;+4.0f} {f'({stats[\"PDIFF_1Y\"]:+.2f}%)':&lt;10} 1 Year\",\n    f\"{stats['DIFF_5Y']:&lt;+4.0f} {f'({stats[\"PDIFF_5Y\"]:+.2f}%)':&lt;10} 5 Years\",\n]\nsubtitle_text = \"\\n\".join(periods)\n\nThe plan is to add these into the plot as a subtitle. I would love to additionally set green and red colors to positive and negative values, but that isn’t currently possible in plotnine. However, #612 suggests this may be possible in the longer term.\n\nimport re\n\n(\n    ggplot(\n        labour_processed_cutted.filter(\n            pl.col(\"YEAR\") &gt;= FILTER_YEAR[0], pl.col(\"YEAR\") &lt;= FILTER_YEAR[1]\n        ),\n        aes(x=\"DATE_YMD\", y=\"centered_rank_across_industry\", fill=\"PDIFF_BINNED\"),\n    )\n    + geom_tile(color=\"white\", height=0.95)\n    + theme_tufte()\n    + theme(\n        text=element_text(family=FONT_PRIMARY),\n        figure_size=FIGURE_THEME_SIZE,\n        axis_text_y=element_text(family=FONT_SECONDARY),\n        axis_text_x=element_text(family=FONT_SECONDARY),\n        axis_title_y=element_text(weight=300),\n        legend_justification_right=1,\n        legend_position=\"right\",\n        legend_text_position=\"right\",\n        legend_title_position=\"top\",\n        legend_key_spacing=0,\n        legend_key_width=15,\n        legend_key_height=15,\n        legend_text=element_text(size=8, family=FONT_SECONDARY),\n        legend_title=element_blank(),\n        plot_title=element_text(ha=\"left\"),\n        plot_subtitle=element_text(ha=\"left\", margin={\"b\": 1, \"units\": \"lines\"}),\n        plot_background=element_rect(fill=COLOR_BACKGROUND, color=COLOR_BACKGROUND),\n    )\n    + scale_fill_manual(values=color_mapping, breaks=order, labels=legend_labels)\n    + guides(fill=guide_legend(ncol=1, reverse=True))\n    + scale_x_datetime(\n        labels=ml.label_date(\"%Y\"),\n        expand=(0, 0),\n        breaks=mb.breaks_date_width(\"1 years\"),\n    )\n    + labs(\n1        title=re.sub(r\" \\[.*?\\]$\", \"\", INDUSTRY),\n2        subtitle=subtitle_text,\n        x=\"\",\n        y=\"&lt; SECTORS FALLING            SECTORS RISING &gt;\",\n    )\n    + geom_point(data=plot_data_subsetted, color=\"black\", fill=\"black\")\n)\n\n\n1\n\nUse inline regex to remove the trailing special characters\n\n2\n\nadd subtitle_text to labs",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#horizontal-legend-with-horizontal-legend-text",
    "href": "02_develop_visualization.html#horizontal-legend-with-horizontal-legend-text",
    "title": "Developing the employment heatmap visualization",
    "section": "5.1 Horizontal legend with horizontal legend text",
    "text": "5.1 Horizontal legend with horizontal legend text\nInitially I wanted a horizontal legend for the colors. But in order to remove the whitespace between keys, I discovered that the text needs to be smaller than the legend keys, otherwise they “push” the legend keys apart in uneven manner. I attempted to (unsuccesfully) address this by making the legend text small, eliminating as much text as possible (e.g. removing the “%” characters for -0.50 and 0.50), and lastly increasing the legend key size.\nBut it still didn’t really work out the way I hoped, so I stuck with a vertical legend instead.",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "02_develop_visualization.html#composing-in-plotnine-is-not-like-rs-patchwork",
    "href": "02_develop_visualization.html#composing-in-plotnine-is-not-like-rs-patchwork",
    "title": "Developing the employment heatmap visualization",
    "section": "5.2 Composing in plotnine is not like R’s patchwork",
    "text": "5.2 Composing in plotnine is not like R’s patchwork",
    "crumbs": [
      "Developing the employment heatmap visualization"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html",
    "href": "01_develop_data_processing.html",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "from pyprojroot import here\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"\n\n\n\n\n\nimport polars as pl\nimport polars.selectors as cs\nfrom mizani.bounds import squish\nfrom pyprojroot import here\nfrom great_tables import GT, md, html\nfrom plotnine import *\nfrom labourcan.data_processing import read_labourcan\n\n\n\n\nread_labourcan returns a polars dataframe with columns:\n\nUnnecessary metadata columns removed\nFiltered to seasonally adjusted estimates only\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour.glimpse()\n\nRows: 12252\nColumns: 10\n$ REF_DATE    &lt;str&gt; '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01'\n$ GEO         &lt;str&gt; 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada'\n$ Industry    &lt;str&gt; 'Total employed, all industries', 'Goods-producing sector', 'Agriculture [111-112, 1100, 1151-1152]', 'Forestry, fishing, mining, quarrying, oil and gas [21, 113-114, 1153, 2100]', 'Utilities [22]', 'Construction [23]', 'Manufacturing [31-33]', 'Services-producing sector', 'Wholesale and retail trade [41, 44-45]', 'Transportation and warehousing [48-49]'\n$ Statistics  &lt;str&gt; 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate'\n$ Data type   &lt;str&gt; 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted'\n$ UOM         &lt;str&gt; 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands'\n$ VALUE       &lt;f64&gt; 9636.7, 3312.5, 463.6, 244.2, 110.4, 654.9, 1839.5, 6324.1, 1592.9, 573.2\n$ YEAR        &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH       &lt;i32&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ DATE_YMD   &lt;date&gt; 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#parameters",
    "href": "01_develop_data_processing.html#parameters",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "from pyprojroot import here\n\n\nLABOUR_DATA_FILE = here() / \"data\" / \"14100355.csv\"",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#libraries",
    "href": "01_develop_data_processing.html#libraries",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "import polars as pl\nimport polars.selectors as cs\nfrom mizani.bounds import squish\nfrom pyprojroot import here\nfrom great_tables import GT, md, html\nfrom plotnine import *\nfrom labourcan.data_processing import read_labourcan",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#read-data",
    "href": "01_develop_data_processing.html#read-data",
    "title": "Processing StatCan Data",
    "section": "",
    "text": "read_labourcan returns a polars dataframe with columns:\n\nUnnecessary metadata columns removed\nFiltered to seasonally adjusted estimates only\nAdditional YEAR, MONTH, and DATE_YMD columns extracted from REF_DATE\nSorted chronologically by year and month\n\n\nlabour = read_labourcan(LABOUR_DATA_FILE)\nlabour.glimpse()\n\nRows: 12252\nColumns: 10\n$ REF_DATE    &lt;str&gt; '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01', '1976-01'\n$ GEO         &lt;str&gt; 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada', 'Canada'\n$ Industry    &lt;str&gt; 'Total employed, all industries', 'Goods-producing sector', 'Agriculture [111-112, 1100, 1151-1152]', 'Forestry, fishing, mining, quarrying, oil and gas [21, 113-114, 1153, 2100]', 'Utilities [22]', 'Construction [23]', 'Manufacturing [31-33]', 'Services-producing sector', 'Wholesale and retail trade [41, 44-45]', 'Transportation and warehousing [48-49]'\n$ Statistics  &lt;str&gt; 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate', 'Estimate'\n$ Data type   &lt;str&gt; 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted', 'Seasonally adjusted'\n$ UOM         &lt;str&gt; 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands', 'Persons in thousands'\n$ VALUE       &lt;f64&gt; 9636.7, 3312.5, 463.6, 244.2, 110.4, 654.9, 1839.5, 6324.1, 1592.9, 573.2\n$ YEAR        &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH       &lt;i32&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ DATE_YMD   &lt;date&gt; 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01, 1976-01-01",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#change-per-month",
    "href": "01_develop_data_processing.html#change-per-month",
    "title": "Processing StatCan Data",
    "section": "% Change per month",
    "text": "% Change per month\nFirst, compute % change from previous month. This needs to be done over different subsets of data:\n\nIndustry\nGeolocation\nLabour Force Characteristic (If provided)\nGender\nAge group\n\nIn the seasonally adjusted dataset, only Industry and Geolocation are provided. The LFC is total employment, the Gender is both, and Age group is all.\n\nlabour_processed = (\n    # if we sort acesnding by time, then lag value is the month before\n    labour.sort([\"Industry\", \"YEAR\", \"MONTH\"])\n    .with_columns(\n        LAGGED_VALUE=pl.col(\"VALUE\")\n        .shift(1)\n        .over([\"Industry\"])\n    )\n    # compute percent difference\n    .with_columns((pl.col(\"VALUE\") - pl.col(\"LAGGED_VALUE\")).alias(\"DIFF\"))\n    .with_columns((pl.col(\"DIFF\") / pl.col(\"LAGGED_VALUE\")).alias(\"PDIFF\"))\n    .select(\n        pl.col(\"Industry\"),\n        cs.matches(\"Labour force characteristics\"),\n        pl.col(\"DATE_YMD\"),\n        pl.col(\"YEAR\"),\n        pl.col(\"MONTH\"),\n        cs.matches(\"VALUE\"),\n        cs.matches(\"DIFF\"),\n    )\n    .sort([\"Industry\", \"YEAR\", \"MONTH\", \"PDIFF\"])\n)\nlabour_processed.glimpse()\n\nRows: 12252\nColumns: 8\n$ Industry      &lt;str&gt; 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]'\n$ DATE_YMD     &lt;date&gt; 1976-01-01, 1976-02-01, 1976-03-01, 1976-04-01, 1976-05-01, 1976-06-01, 1976-07-01, 1976-08-01, 1976-09-01, 1976-10-01\n$ YEAR          &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH         &lt;i32&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n$ VALUE         &lt;f64&gt; 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5, 428.9\n$ LAGGED_VALUE  &lt;f64&gt; None, 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5\n$ DIFF          &lt;f64&gt; None, 3.2000000000000455, 4.599999999999966, 0.0, 8.0, 3.900000000000034, 6.0, 6.099999999999966, -0.19999999999998863, 5.399999999999977\n$ PDIFF         &lt;f64&gt; None, 0.008165348303138672, 0.011642622120981943, 0.0, 0.020015011258443835, 0.009565857247976537, 0.014577259475218658, 0.014607279693486507, -0.0004720320981826496, 0.012750885478158152",
    "crumbs": [
      "Processing StatCan Data"
    ]
  },
  {
    "objectID": "01_develop_data_processing.html#signed-centered-rank",
    "href": "01_develop_data_processing.html#signed-centered-rank",
    "title": "Processing StatCan Data",
    "section": "Signed Centered Rank",
    "text": "Signed Centered Rank\nNow we can compute the signed centered rank.\nDefine centered_rank_expr function which takes a polars series and returns an expression, meaning it can be used in a polars with_columns call, which is nice because it can take advantage of polars lazy-evaluation optimization.\nBelow is the definition and a test-case.\n\ndef centered_rank_expr(col):\n    \"\"\"\n    - Largest negative value gets rank -1\n    - Smallest positive value gets rank +1\n    - Zero gets rank 0\n    \"\"\"\n    return (\n        pl.when(col &lt; 0)\n        .then(\n            # minus the total # of -ve values\n            (col.rank(method=\"ordinal\", descending=True) * -1) + (col &gt; 0).sum()\n        )\n        .when(col == 0)\n        .then(pl.lit(0))\n        .when(col &gt; 0)\n        .then(col.rank(method=\"ordinal\") - (col &lt; 0).sum())\n        .otherwise(pl.lit(None))\n    )\n\n# test it on this subset of data\ntest_series = (\n    # .filter(pl.col(\"Labour force characteristics\") == \"Employment\")\n    labour_processed\n    .with_columns(pl.col(\"PDIFF\").round(decimals=4))\n    .filter(pl.col(\"YEAR\") == 2025, pl.col(\"MONTH\") == 1)\n    .select(pl.col(\"PDIFF\"))\n    .sample(n=10, seed=1)\n    .select(\"PDIFF\")\n)\n\ntest_series.with_columns(centered_rank_expr(pl.col(\"PDIFF\")).alias(\"rank\")).sort(\n    \"PDIFF\"\n)\n\n\nshape: (10, 2)\n\n\n\nPDIFF\nrank\n\n\nf64\ni64\n\n\n\n\n-0.0336\n-5\n\n\n-0.0207\n-4\n\n\n-0.0177\n-3\n\n\n-0.0101\n-2\n\n\n-0.003\n-1\n\n\n0.0006\n1\n\n\n0.0109\n2\n\n\n0.0122\n3\n\n\n0.0179\n4\n\n\n0.044\n5\n\n\n\n\n\n\nLooks good, so now we can apply to the data:\n\nlabour_processed = labour_processed.with_columns(\n    centered_rank_across_industry=centered_rank_expr(pl.col(\"PDIFF\")).over(\n        [\"YEAR\", \"MONTH\"]\n    )\n)\nlabour_processed.glimpse()\n\nRows: 12252\nColumns: 9\n$ Industry                       &lt;str&gt; 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]', 'Accommodation and food services [72]'\n$ DATE_YMD                      &lt;date&gt; 1976-01-01, 1976-02-01, 1976-03-01, 1976-04-01, 1976-05-01, 1976-06-01, 1976-07-01, 1976-08-01, 1976-09-01, 1976-10-01\n$ YEAR                           &lt;i32&gt; 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976, 1976\n$ MONTH                          &lt;i32&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n$ VALUE                          &lt;f64&gt; 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5, 428.9\n$ LAGGED_VALUE                   &lt;f64&gt; None, 391.9, 395.1, 399.7, 399.7, 407.7, 411.6, 417.6, 423.7, 423.5\n$ DIFF                           &lt;f64&gt; None, 3.2000000000000455, 4.599999999999966, 0.0, 8.0, 3.900000000000034, 6.0, 6.099999999999966, -0.19999999999998863, 5.399999999999977\n$ PDIFF                          &lt;f64&gt; None, 0.008165348303138672, 0.011642622120981943, 0.0, 0.020015011258443835, 0.009565857247976537, 0.014577259475218658, 0.014607279693486507, -0.0004720320981826496, 0.012750885478158152\n$ centered_rank_across_industry  &lt;i64&gt; None, 8, 11, 0, 8, 8, 9, 8, -1, 5\n\n\n\nCheck output visually for 1 year 1 month\n\n# check 1 year 1 month\n(\n    labour_processed\n    .with_columns(pl.col(\"PDIFF\").round(decimals=4))\n    .filter(pl.col(\"YEAR\") == 2025)\n    .sort([\"YEAR\", \"MONTH\", \"PDIFF\"])\n    .select([\"YEAR\", \"MONTH\", \"Industry\", \"VALUE\", \"DIFF\", \"PDIFF\", cs.matches(\"rank\")])\n)\n\n\nshape: (168, 7)\n\n\n\nYEAR\nMONTH\nIndustry\nVALUE\nDIFF\nPDIFF\ncentered_rank_across_industry\n\n\ni32\ni32\nstr\nf64\nf64\nf64\ni64\n\n\n\n\n2025\n1\n\"Wholesale trade [41]\"\n689.4\n-24.0\n-0.0336\n-8\n\n\n2025\n1\n\"Utilities [22]\"\n155.8\n-3.3\n-0.0207\n-7\n\n\n2025\n1\n\"Other services (except public …\n771.0\n-13.9\n-0.0177\n-6\n\n\n2025\n1\n\"Forestry, fishing, mining, qua…\n337.1\n-5.6\n-0.0163\n-5\n\n\n2025\n1\n\"Business, building and other s…\n726.4\n-7.4\n-0.0101\n-4\n\n\n…\n…\n…\n…\n…\n…\n…\n\n\n2025\n8\n\"Accommodation and food service…\n1177.1\n9.2\n0.0079\n5\n\n\n2025\n8\n\"Construction [23]\"\n1636.3\n17.1\n0.0106\n6\n\n\n2025\n8\n\"Agriculture [111-112, 1100, 11…\n217.7\n4.8\n0.0225\n7\n\n\n2025\n8\n\"Utilities [22]\"\n163.5\n4.7\n0.0296\n8\n\n\n2025\n8\n\"Wholesale trade [41]\"\n731.1\n27.6\n0.0392\n9",
    "crumbs": [
      "Processing StatCan Data"
    ]
  }
]